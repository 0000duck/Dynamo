<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AndDescription" xml:space="preserve">
    <value>Boolean AND: Returns true only if both of the inputs are true. If either is false, returns false.</value>
    <comment>Description for And</comment>
  </data>
  <data name="BooleanDescription" xml:space="preserve">
    <value>Selection between a true and false.</value>
    <comment>Description for Boolean</comment>
  </data>
  <data name="ColorRangeDescription" xml:space="preserve">
    <value>Get a color given a color range.</value>
    <comment>Description for Color Range</comment>
  </data>
  <data name="DirectoryFromPathDescription" xml:space="preserve">
    <value>Creates a directory object from a path.</value>
    <comment>Description for Directory.FromPath</comment>
  </data>
  <data name="DirectoryPathDescription" xml:space="preserve">
    <value>Allows you to select a directory on the system to get its path.</value>
    <comment>Description for Directory Path</comment>
  </data>
  <data name="DoubleSliderDescription" xml:space="preserve">
    <value>A slider that produces double values.</value>
    <comment>Description for Double Slider</comment>
  </data>
  <data name="FileFromPathDescription" xml:space="preserve">
    <value>Creates a file object from a path.</value>
    <comment>Description for File.FromPath</comment>
  </data>
  <data name="FilePathDescription" xml:space="preserve">
    <value>Allows you to select a file on the system to get its filename.</value>
    <comment>Description for File Path</comment>
  </data>
  <data name="FormulaDescription" xml:space="preserve">
    <value>Evaluates mathematical formulas. Uses NCalc: http://ncalc.codeplex.com/</value>
    <comment>Description for Formula</comment>
  </data>
  <data name="FunctionApplyDescription" xml:space="preserve">
    <value>Applies a function to arguments.</value>
    <comment>Description for Function.Apply</comment>
  </data>
  <data name="FunctionComposeDescription" xml:space="preserve">
    <value>Compose multiple functions.</value>
    <comment>Description for Function.Compose</comment>
  </data>
  <data name="IfDescription" xml:space="preserve">
    <value>Conditional statement</value>
    <comment>Description for If</comment>
  </data>
  <data name="IntegerSliderDescription" xml:space="preserve">
    <value>A slider that produces integer values.</value>
    <comment>Description for Integer Slider</comment>
  </data>
  <data name="LegacyNodeDescription" xml:space="preserve">
    <value>This is an obsolete node</value>
    <comment>Description for Legacy Node</comment>
  </data>
  <data name="ListCartesianProductDescription" xml:space="preserve">
    <value>Applies a combinator to each pair in the cartesian product of two sequences</value>
    <comment>Description for List.CartesianProduct</comment>
  </data>
  <data name="ListCombineDescription" xml:space="preserve">
    <value>Applies a combinator to each element in two sequences</value>
    <comment>Description for List.Combine</comment>
  </data>
  <data name="ListCreateDescription" xml:space="preserve">
    <value>Makes a new list out of the given inputs</value>
    <comment>Description for List.Create</comment>
  </data>
  <data name="ListFilterDescription" xml:space="preserve">
    <value>Filters a sequence by a given condition such that for an arbitrary element "x," condition(x) = True or False.</value>
    <comment>Description for List.Filter</comment>
  </data>
  <data name="ListForEachDescription" xml:space="preserve">
    <value>Performs a computation on each element of a list. Does not accumulate results.</value>
    <comment>Description for List.ForEach</comment>
  </data>
  <data name="ListLaceLongestDescription" xml:space="preserve">
    <value>Applies a combinator to each pair resulting from a longest lacing of the input lists. All lists have their last element repeated to match the length of the longest input.</value>
    <comment>Description for List.LaceLongest</comment>
  </data>
  <data name="ListLaceShortestDescription" xml:space="preserve">
    <value>Applies a combinator to each pair resulting from a shortest lacing of the input lists. All lists are truncated to the length of the shortest input.</value>
    <comment>Description for List.LaceShortest</comment>
  </data>
  <data name="ListMapDescription" xml:space="preserve">
    <value>Applies a function over all elements of a list, generating a new list from the results.</value>
    <comment>Description for List.Map</comment>
  </data>
  <data name="ListReduceDescription" xml:space="preserve">
    <value>Reduces a list into a new value by combining each element with an accumulated result.</value>
    <comment>Description for List.Reduce</comment>
  </data>
  <data name="ListScanDescription" xml:space="preserve">
    <value>Reduces a list into a new value by combining each element with an accumulated result, produces a list of successive reduced values.</value>
    <comment>Description for List.Scan</comment>
  </data>
  <data name="NumberRangeDescription" xml:space="preserve">
    <value>Creates a sequence of numbers in the specified range.</value>
    <comment>Description for Number Range</comment>
  </data>
  <data name="NumberSequenceDescription" xml:space="preserve">
    <value>Creates a sequence of numbers.</value>
    <comment>Description for Number Sequence</comment>
  </data>
  <data name="OrDescription" xml:space="preserve">
    <value>Boolean OR: Returns true if either of the inputs are true. If neither are true, returns false.</value>
    <comment>Description for Or</comment>
  </data>
  <data name="ReplaceByConditionDescription" xml:space="preserve">
    <value>Replaces an object with a given substitute if the original object satisfies a given condition.</value>
    <comment>Description for ReplaceByCondition</comment>
  </data>
  <data name="ScopeIfDescription" xml:space="preserve">
    <value>Scoped If statement</value>
    <comment>Description for Scope If</comment>
  </data>
  <data name="StringfromArrayDescription" xml:space="preserve">
    <value>Convert an array to a string representation.</value>
    <comment>Description for String from Array</comment>
  </data>
  <data name="StringfromObjectDescription" xml:space="preserve">
    <value>Convert an object to a string representation.</value>
    <comment>Description for String from Object</comment>
  </data>
  <data name="WatchDescription" xml:space="preserve">
    <value>Visualize the output of node.</value>
    <comment>Description for Watch</comment>
  </data>
  <data name="WatchImageDescription" xml:space="preserve">
    <value>Previews an image</value>
    <comment>Description for Watch Image</comment>
  </data>
  <data name="WebRequestDescription" xml:space="preserve">
    <value>Make a web request given a url.</value>
    <comment>Description for Web Request</comment>
  </data>
</root>